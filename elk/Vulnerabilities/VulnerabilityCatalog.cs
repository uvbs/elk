namespace Elk.Vulnerabilities
{
  using Elk.DataTypes.Enumerations;
  using Elk.DataTypes.Interfaces;
  using System.Collections.Generic;


  public class VulnerabilityDefinitions
  {
    #region MEMBERS    

    private Dictionary<EnumVulnerability, IVulnerabilityDefinition> vulnerabilityCatalogDict = new Dictionary<EnumVulnerability, IVulnerabilityDefinition>();
    private static VulnerabilityDefinitions instance;

    #endregion


    #region PROPERTIES

    public static VulnerabilityDefinitions Instance { get { return instance ?? (instance = new VulnerabilityDefinitions()); } set { } }

    public Dictionary<EnumVulnerability, IVulnerabilityDefinition> Catalog { get { return this.vulnerabilityCatalogDict; } set { } }

    #endregion


    #region PRIVATE

    private VulnerabilityDefinitions()
    {
      this.vulnerabilityCatalogDict.Add(EnumVulnerability.NoHttpAvailable, new NoHttpsAvailable());
      this.vulnerabilityCatalogDict.Add(EnumVulnerability.NoHttpsUsed, new NoHttpsUsed());
      this.vulnerabilityCatalogDict.Add(EnumVulnerability.HttpsByTemporaryRedirectsOnly, new HttpsByTemporaryRedirectsOnly());
      this.vulnerabilityCatalogDict.Add(EnumVulnerability.HttpsByTemporaryAndPermanentRedirectsMix, new HttpsByTemporaryAndPermanentRedirectsMix());
      this.vulnerabilityCatalogDict.Add(EnumVulnerability.HttpsByPermanentRedirectsOnly, new HttpsByPermanentRedirectsOnly());
      this.vulnerabilityCatalogDict.Add(EnumVulnerability.HttpsByHstsAndNoSubdomains, new HttpsByHstsAndNoSubdomains());
      this.vulnerabilityCatalogDict.Add(EnumVulnerability.HttpsByHstsAndSubdomains, new HttpsByHstsAndSubdomains());
    }

    #endregion

  }
}
